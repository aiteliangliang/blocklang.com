# 页面

一个完整的程序模块由一个前端页面和多个后端服务组成，然后使用后端服务的 URL 将前端和后端关联起来。我们将用户可以看到的、可以交互的前端称为**页面**。

## 页面组成

随着 web 技术的发展，我们理解或看待“页面”的角度一直在变化，朝着更规范、更简单的方向变。我们借助时下流行的 MVVM(Model-View-ViewModel) 框架重新审视界面，归纳出页面三要素，但旧瓶装新酒，边界更清晰，内涵更丰富。

页面的三个组成要素：

1. 外观(ui)
2. 数据(data) - 指本地数据结构
3. 行为(behavior)

还有一个元素，称为外部接口，或者称为远程数据，是与行为关联的。

### 外观

一个网页的外观是由 HTML 和 CSS 实现的，但 HTML 和 CSS 都是实现细节，如果直接依赖实现细节，我们就没有办法用相同的概念描述 Android 页面或 iOS 页面，所以我们将外观的组成抽象为：

1. 结构 - 使用 UI 组件逐层嵌套形成树状结构，且只有一个根节点，并称之为 `Page`
2. 样式 - 使用主题的概念统一设置和更换样式，如 `Dojo Theme` 技术

注意：为了让概念更加简单和纯粹，我们认为结构只能由 **UI 组件**一种元素组成。

#### `Page` 部件

`Page` 部件是一个特殊的部件：

1. `Page` 部件是一个页面的根节点，一个页面只能有一个根节点；
2. `Page` 部件上要能设置 `onLoad` 等管理页面生命周期的函数；
3. 因为 `Page` 部件要管理页面的生命周期，所以不适合交由用户开发；
4. 通过根节点来区分一个资源是页面还是页面模板
   1. 在创建一个页面时，要默认加上 `Page` 部件，作为页面的根节点；
   2. 在创建一个页面模板时，不能用 `Page` 部件作为根节点，而是用专门的 `PageTemplate` 部件；

实现方式：

1. 定义一个组件库，其中包含 `Page` 等 BlockLang 内置功能，这些库称为标准库；
2. 标准库跟普通的组件库一样，也需要注册到组件市场中，但需要标识出为标准库，所以标准库也是支持切换的；
3. 不能在组件市场中显示标准库，因为组件市场中的仓库都可以由用户添加为项目依赖，而标准库本身已经是项目依赖了；
4. 每个项目依赖中默认包含这些标准库，但不要显示在界面上，也不用在项目依赖表中显式配置（如 rust 的 prelude）；
5. 在创建页面时，从指定的标准库中选择指定的部件作为页面的根节点；
6. 标准库也包含三个库：
   1. API 项目 - 名称以 `std-api-` 开头；
   2. 组件项目 - 名称以 `std-` 开头；
   3. 设计器项目 - 名称以 `std-ide-` 开头。

注意：标准库与普通库是一样的，唯一的区别是：

1. 普通库是用户为项目添加依赖，并由用户选择添加到页面中的部件；
1. 而标准库是 BlockLang 默认为项目添加的依赖，并由 BlockLang 初始化设置页面中的部件;
1. 标准库是在 PageDesigner 中内置引用，普通库是通过创建 script 节点按需、延迟引入的。

### 数据

一个应用程序中的数据可根据使用范围划分层级：

1. 全局数据 - 全局共享的数据，所有页面都可以使用
2. 页面数据 - 只有所在的页面才可以使用

页面数据本可以再进一步细分，如按区块等，但如果我们使用 `React Redux` 或 `Dojo Store` 等技术将页面中的数据集中存储后，就无需进一步拆分。

页面中的数据，分为两大类：

1. 业务数据
2. 交互数据 - 如数据有效性校验结果和提示信息等

页面中的数据会独立、集中存储，但又能注入到页面的结构中。

### 行为

一提到页面中的行为或交互，我们就想到了 JavaScript。但 JavaScript 依然是实现细节，我们将 JavaScript 做的所有事情抽象为一个概念，并称之为“行为”。

只有外观和数据的页面，只能称为静态页面，显然我们日常使用的更多是动态页面，这就需要在静态页面上加上变的因素，我们也称之为“行为”。

在介绍静态页面往动态页面的转换时，需要先介绍一个重要概念：驱动。页面不会无缘无故的变，它必然是由其他因素驱动着变的。

目前总结出两种**驱动**页面变化的原因：

1. 数据变更驱动（内因）
2. 用户交互驱动（外因）

在介绍外观和数据时，我们不仅说明了如何拔高抽象，也说明了如何落地实现。同样，行为也需要落地实现，我们使用函数来描述一个行为。

## 页面模型

一个页面由外观、数据和行为三要素组成，而外观和行为可统一使用组件模型描述，这样就可以定义出**页面模型**。

组件模型包括：

1. 组件
2. 组件属性
3. 组件属性值

TODO: 添加模型的结构说明

## 数据库表

需设计出以下数据库表存储一个页面信息：

* 外观
  * `page_ui_widget` - 页面部件
  * `page_ui_widget_attr_value` - 页面部件的属性值
* 数据
  * `page_data` - 页面数据
* 行为
  * `page_behavior_func` - 函数签名中的函数名和返回结果的数据类型
  * `page_behavior_func_params` - 函数的输入参数
  * `page_behavior_func_body` - 函数体
  * `page_behavior_func_body_attr_value` - 函数调用的参数值

因为 UI 和行为最终都归为组件，而组件都需要设置属性值，所以有 `{组件}_attr_value` 表。

简化数据库表的命名：

1. 名字的第二层，如 `ui` 和 `behavior` 表示分类，而第三层 `widget` 和 `func` 对应对应的实现，可以只出现一个；
2. 如果不去掉一层，表名很容易超过 Oracle 限制的 30 个字符。

因此调整为：

* 外观
  * `page_widget` - 页面部件
  * `page_widget_attr_value` - 页面部件的属性值
* 数据
  * `page_data` - 页面数据
* 行为
  * `page_func` - 函数签名中的函数名和返回结果的数据类型
  * `page_func_params` - 函数的输入参数
  * `page_func_body` - 函数体
  * `page_func_body_attr_value` - 函数调用的参数值

同时，Block Lang 页面也要支持本地化和国际化。

关于性能优化

可考虑创建一张表 `page_model` 直接存储页面模型的 json 字符串。但有一点需要注意，在页面设计器中，一个部件的属性可能会有默认值，所以不管有没有明确设置值，都需要加载全部的属性列表，当升级 API 依赖时，一个部件的属性列表可能会有增减，所以在升级后直接从 `page_model` 获取的页面模型，就会出现属性不全的情况，这样在设计器中就会出现属性设置串位的错误。所以发现需要升级，就需要从页面模型的结构化表中重新加载。所以 `page_model` 表作为优化方案，在 1.0.0 版本之后再详细设计。 

### 升级组件

一个页面依赖的是 UI 组件（Widget），如何确保 UI 组件升级后，页面依然能够识别到原来依赖的 UI 组件？

如果页面的 id 为 P_A，其中嵌套两个 UI 组件，id 分别为 W_B_ID 和 W_C_ID，直接使用 id 关联，则关联关系为：

| ID  | 页面 | 部件   | 父部件            |
| --- | ---- | ------ | ----------------- |
| 1   | P_A  | W_B_ID | -1                |
| 2   | P_A  | W_C_ID | 1 (父部件实例 ID) |

当 UI 组件所实现的 API 库升级后，则 UI 组件的 id 会发生变化（因支持同时存储部件的多个版本），如变为 W_B_2 和 W_C_1，则 P_A 无法定位到 id 为 W_B_ID 和 W_C_ID 的部件。因此如何做到既能升级 API 库版本，又不影响页面与部件的关系呢？需要做以下组合：

1. 项目依赖的组件库版本只能在 `DEPENDENCE.json` 中维护；
2. 使用页面 id、API 库标识和组件 `CODE` 三个字段维护页面和组件的关系。

因为一个 API 库中的 `CODE` 在各个版本中都是相同的，不依赖于版本变化（id 是依赖于版本变化的），这样通过修改 `DEPENDENCE.json` 中 API 库的版本，就可以升级版本，而页面和部件之间的关系也无需改变。如下：

| ID  | 页面 | API 仓库标识 | 部件     | 父部件            |
| --- | ---- | ------------ | -------- | ----------------- |
| 1   | P_A  | 1            | U_B_CODE | -1                |
| 2   | P_A  | 1            | U_C_CODE | 1 (父部件实例 ID) |

### 存储页面数据

页面中的数据是独立和集中存储的。在 `page_data` 表中要存两类数据：数据结构和默认数据。而难点也就在于如何用一套表结构存储这两类数据。

接下来，我们基于数据类型详细说明。

#### 基本数据类型

```text
name: "name1", type:"string", defaultValue: "value1"
```

其中

1. 通过 `name` 和 `type` 等属性定义数据类型
2. 结合嵌套组合定义数据结构
3. 使用 `defaultValue` 设置默认数据

以上三条，我们称为页面数据定义三步骤（下面简称**三步法**）。

#### Json Object

```text
name: "object1", type: "Object"
  | name: "name", type: "string", defaultValue: "user1"
  | name: "password", type: "string", defaultValue: "password1"
```

同样使用三步法

1. 将 `type` 的值设置为 `Object`
2. 然后定义 Json Object 的结构
   1. 在其下嵌套基本数据类型
   2. 逐个字段设置数据类型
   3. 逐个字段设置 `defaultValue`，就相当于为 Json Object 设置了默认值

#### Json Array

要在一套表结构中定义出 Json Array 的结构并设置默认数据，有些困难。因为我们通常首先想到的是数组中各元素的类型相同，所以我们只需定义一套数据类型，而数组的默认数据可以是多条数据，两者维度不一样就不好一块定义。

我们发现约定数组中各元素类型相同，可能是一个特殊场景，比如 JavaScript 数组中就能存储不同类型的数据；Java、Python 和 Rust 等语言中虽然约定数组元素的类型必须相同，但我们经常用于描述多条记录的 `List` 却可以存储不同类型的元素，所以我们将页面数据中的 Json Array 定义为能存储不同数据类型的元素。

这样就完全可以使用上面说的三步法来定义一个 Json Array，即在 Json Array 下嵌套多个 Json Object 或基本数据类型，而每个 Json Object 或数据类型定义自己的数据结构和默认值。

这样会出现另一个不足之处，如果数组的元素类型相同，就会出现数组的每个默认值都自带一套数据类型，且完全相同，出现冗余。但这是当前权衡后的最好方案，但也不能就此止步，需持续优化出更好的方案。同时，我们在界面设计上为用户提供便利工具，让用户感受不到重复定义的繁琐。

结构如下：

```text
name: "array1", type: "Array"
  | name: "user1", type: "Object"
      | name: "name", type: "string", defaultValue: "user1"
      | name: "password", type: "string", defaultValue: "password1"
  | name: "user2", type: "Object"
      | name: "name", type: "string", defaultValue: "user2"
      | name: "password", type: "string", defaultValue: "password1"
```

当然 Array 中可以混着存放 Json Object 和基本类型。

### 定义并存储页面行为

#### 如何定义页面行为

页面上的一个行为对应一个函数，要解决好函数的定义和使用。

在函数体中调用对象有两种：

1. 客户端组件（对应一个函数）
2. 用户在页面中自定义的函数

而一个完整的函数签名通常包括三部分：

1. 函数名 - 一个表示名称字符串
2. 输入参数列表 - 表示参数的名称和参数的数据类型，可以是 0 到多个
3. 返回结果 - 一个表示返回结果数据类型的字符串，可以是无返回类型、基本类型或者用户自定义类型

有关函数的输入参数和输出参数，有两种实现方式：

1. 函数签名中包含形参和返回值
   1. 为函数添加形参
   2. 函数支持返回值
2. 函数签名中不包含形参和返回值，而是在函数调用中
   1. 使用 Data 组件获取数据（相当于输入参数）
   2. 使用 Data 组件设置数据（相当于返回结果）

如果不支持嵌套调用自定义函数，则第二种方式就完全可以满足；如果支持嵌套调用自定义函数，则就需要支持第一种方式。

#### 调用 RESTful API

RESTful API 与 API 组件和功能组件不同。

有关调用 RESTful API（也适用于所有第三方 API），有两种处理方式：

1. 使用 `Fetch` 等功能组件直接调用 RESTful API
2. 将 RESTful API 封装称为功能组件，然后直接调用此封装好的功能组件

第一种方式常用于本地 RESTful API；第二种方式常用于第三方 RESTful API。

通常调用一个功能组件时，只需要设置该功能组件的属性值；但是使用 `Fetch` 或 `xhr` 功能组件调用 RESTful API 时，既需要设置 `Fetch` 或 `xhr` 等功能组件的属性，同时也要设置被调用的 RESTful API 的输入参数等属性。

TODO：`page_func_body_attr_value` 表结构待定

这一块的表结构设计比较绕，要么增加一张 `page_func_body_service_attr_value` 表专门存储 RESTful API 相关的属性值，要么扩展 `page_func_body_attr_value` 表，增加 `parent_id`、`method_id` 和 `attr_type` 字段。

或者一个页面包含四部分：外观、数据、行为和外部接口。其中外部接口是与行为关联的。

这样的话就可以增加一张数据库表 `page_service`，其中存 `page_func_body_attr_value` 表的 `dbid`？这样也就可以直观统计一个页面中使用了哪些数据服务。

#### `行为`数据库表

以下是支持形参和返回值的表结构设计：

* `page_func` 中存函数签名中的函数名和返回结果
* `page_func_params` - 中存储函数签名中的输入参数
* `page_func_body` - 存储函数体中的调用语句，支持嵌套调用，调用的对象包括客户端组件和页面中的自定义函数
* `page_func_body_attr_value` - 在调用组件或自定义函数时设置的参数信息

表的作用：

* 通过 `page_func`、`page_func_params` 和 `page_func_body` 三张表实现了定义函数
* 通过 `page_func`、`page_func_body` 和 `page_func_body_attr_value` 三张表实现了调用函数

TODO: 客户端组件的函数调用面板布局等，需用户自定义；但是自定义函数的调用面板，用户无法自定义，需提供一致的布局。
