# 页面

一个完整的程序模块由一个前端页面和多个后端服务组成，然后使用后端服务的 URL 将前端和后端关联起来。我们将用户可以看到的、可以交互的前端称为**页面**。

随着 web 技术的发展，我们理解或看待“页面”的角度一直在变化，朝着更规范、更简单的方向变。我们借助时下流行的 MVVM(Model-View-ViewModel) 框架重新审视界面，归纳出页面三要素，但旧瓶装新酒，边界更清晰，内涵更丰富。

页面的三个组成要素：

1. 外观(ui)
2. 数据(data)
3. 行为(behavior)

## 外观

一个网页的外观是由 HTML 和 CSS 实现的，但 HTML 和 CSS 都是实现细节，如果直接依赖实现细节，我们就没有办法用相同的概念描述 Android 页面或 iOS 页面，所以我们将外观的组成抽象为：

1. 结构 - 使用 UI 组件逐层嵌套形成树状结构，且只有一个根节点，并称之为 `Page`
2. 样式 - 使用主题的概念统一设置和更换样式，如 `Dojo Theme` 技术

注意：为了让概念更加简单和纯粹，我们认为结构只能由 **UI 组件**一种元素组成。

## 数据

一个应用程序中的数据可根据使用范围划分层级：

1. 全局数据 - 全局共享的数据，所有页面都可以使用
2. 页面数据 - 只有所在的页面才可以使用

页面数据本可以再进一步细分，如按区块等，但如果我们使用 `React Redux` 或 `Dojo Store` 等技术将页面中的数据集中存储后，就无需进一步拆分。

页面中的数据，分为两大类：

1. 业务数据
2. 交互数据 - 如数据有效性校验结果和提示信息等

页面中的数据会独立、集中存储，但又能注入到页面的结构中。

## 行为

一提到页面中的行为或交互，我们就想到了 JavaScript。但 JavaScript 依然是实现细节，我们将 JavaScript 做的所有事情抽象为一个概念，并称之为“行为”。

只有外观和数据的页面，只能称为静态页面，显然我们日常使用的更多是动态页面，这就需要在静态页面上加上变的因素，我们也称之为“行为”。

在介绍静态页面往动态页面的转换时，需要先介绍一个重要概念：驱动。页面不会无缘无故的变，它必然是由其他因素驱动着变的。

目前总结出两种**驱动**页面变化的原因：

1. 数据变更驱动（内因）
2. 用户交互驱动（外因）

在介绍外观和数据时，我们不仅说明了如何拔高抽象，也说明了如何落地实现。同样，行为也需要落地实现，我们使用纯函数来描述一个行为。

> 纯函数：返回结果只依赖于它的参数，并且在执行过程里面没有副作用，是幂等的，无状态的。

## 页面模型

一个页面由外观、数据和行为三要素组成，而外观和行为可统一使用组件模型描述，这样就可以定义出**页面模型**。

组件模型包括：

1. 组件
2. 组件属性
3. 组件属性值

TODO: 添加模型的结构说明

## 数据库表

需设计出以下数据库表存储一个页面信息：

* 外观
  * `page_ui_widget` - 页面部件
  * `page_ui_widget_attr_value` - 页面部件的属性值
* 数据
  * `page_data` - 页面数据
* 行为
  * `page_behavior` - 页面行为
  * `page_behavior_attr_value` - 页面行为的属性值

因为 UI 和行为最终都归为组件，而组件都需要设置属性值，所以有 `{组件}_attr_value` 表。

同时，Block Lang 页面也要支持本地化和国际化。

### 升级组件

一个页面依赖的是 UI 组件（Widget），如何确保 UI 组件升级后，页面依然能够识别到原来依赖的 UI 组件？

如果页面的 id 为 P_A，其中嵌套两个 UI 组件，id 分别为 W_B_ID 和 W_C_ID，直接使用 id 关联，则关联关系为：

| ID  | 页面 | 部件   | 父部件            |
| --- | ---- | ------ | ----------------- |
| 1   | P_A  | W_B_ID | -1                |
| 2   | P_A  | W_C_ID | 1 (父部件实例 ID) |

当 UI 组件所实现的 API 库升级后，则 UI 组件的 id 会发生变化（因支持同时存储部件的多个版本），如变为 W_B_2 和 W_C_1，则 P_A 无法定位到 id 为 W_B_ID 和 W_C_ID 的部件。因此如何做到既能升级 API 库版本，又不影响页面与部件的关系呢？需要做以下组合：

1. 项目依赖的组件库版本只能在 `DEPENDENCE.json` 中维护；
2. 使用页面 id、API 库标识和组件 `CODE` 三个字段维护页面和组件的关系。

因为一个 API 库中的 `CODE` 在各个版本中都是相同的，不依赖于版本变化（id 是依赖于版本变化的），这样通过修改 `DEPENDENCE.json` 中 API 库的版本，就可以升级版本，而页面和部件之间的关系也无需改变。如下：

| ID  | 页面 | API 仓库标识 | 部件     | 父部件            |
| --- | ---- | ------------ | -------- | ----------------- |
| 1   | P_A  | 1            | U_B_CODE | -1                |
| 2   | P_A  | 1            | U_C_CODE | 1 (父部件实例 ID) |

### 存储页面数据

页面中的数据是独立和集中存储的。在 `page_data` 表中要存两类数据：数据结构和默认数据。而难点也就在于如何用一套表结构存储这两类数据。

接下来，我们基于数据类型详细说明。

#### 基本数据类型

```text
name: "name1", type:"string", defaultValue: "value1"
```

其中

1. 通过 `name` 和 `type` 等属性定义数据类型
2. 结合嵌套组合定义数据结构
3. 使用 `defaultValue` 设置默认数据

以上三条，我们称为页面数据定义三步骤（下面简称**三步法**）。

#### Json Object

```text
name: "object1", type: "Object"
  | name: "name", type: "string", defaultValue: "user1"
  | name: "password", type: "string", defaultValue: "password1"
```

同样使用三步法

1. 将 `type` 的值设置为 `Object`
2. 然后定义 Json Object 的结构
   1. 在其下嵌套基本数据类型
   2. 逐个字段设置数据类型
   3. 逐个字段设置 `defaultValue`，就相当于为 Json Object 设置了默认值

#### Json Array

要在一套表结构中定义出 Json Array 的结构并设置默认数据，有些困难。因为我们通常首先想到的是数组中各元素的类型相同，所以我们只需定义一套数据类型，而数组的默认数据可以是多条数据，两者维度不一样就不好一块定义。

我们发现约定数组中各元素类型相同，可能是一个特殊场景，比如 JavaScript 数组中就能存储不同类型的数据；Java、Python 和 Rust 等语言中虽然约定数组元素的类型必须相同，但我们经常用于描述多条记录的 `List` 却可以存储不同类型的元素，所以我们将页面数据中的 Json Array 定义为能存储不同数据类型的元素。

这样就完全可以使用上面说的三步法来定义一个 Json Array，即在 Json Array 下嵌套多个 Json Object 或基本数据类型，而每个 Json Object 或数据类型定义自己的数据结构和默认值。

这样会出现另一个不足之处，如果数组的元素类型相同，就会出现数组的每个默认值都自带一套数据类型，且完全相同，出现冗余。但这是当前权衡后的最好方案，但也不能就此止步，需持续优化出更好的方案。同时，我们在界面设计上为用户提供便利工具，让用户感受不到重复定义的繁琐。

结构如下：

```text
name: "array1", type: "Array"
  | name: "user1", type: "Object"
      | name: "name", type: "string", defaultValue: "user1"
      | name: "password", type: "string", defaultValue: "password1"
  | name: "user2", type: "Object"
      | name: "name", type: "string", defaultValue: "user2"
      | name: "password", type: "string", defaultValue: "password1"
```

当然 Array 中可以混着存放 Json Object 和基本类型。
